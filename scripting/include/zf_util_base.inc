////////////////////////////////////////////////////////////////////////////////
//
//  Z O M B I E - F O R T R E S S - [TF2]
//
//  ZF Utility Base File
//
//  Includes stock routines for team, class, weapons, attributes, ammo,
//  spawning, and damage logic.
//
////////////////////////////////////////////////////////////////////////////////

// TODO
// m_flMaxSpeed appears to be reset/recalculated when:
// + after switching weapons and before next prethinkpost
// + (soldier holding equalizer) every 17-19 frames

#if defined _ZF_UTIL_BASE_INC
  #endinput
#endif
#define _ZF_UTIL_BASE_INC

//
// ZF Damage Constants
//
#define TF2_DMGTYPE_BLEED         0x4
#define TF2_DMGTYPE_FALL          0x20
#define TF2_DMGTYPE_EXPLOSIVE     0x40
#define TF2_DMGTYPE_BLUDGEON      0x80
#define TF2_DMGTYPE_FIRE          0x800
#define TF2_DMGTYPE_CRIT          0x100000

#define ZF_DMGTYPE_POISON         0x8000_0000 // Should be unused

#define ZF_NODAMAGE_NAME          "zfnodmg"
#define ZF_DAMAGEPOINT_NAME       "zfdmgpnt"
#define ZF_DAMAGERADIUS_NAME      "zfdmgrad"

//
// ZF Weapon Constants / Objects
// Bits 31-16 : Flags
// Bits 15-08 : Max clip ammo
// Bits 07-00 : Max reserve ammo
//
#define M_MAXRESAMMO    0x000000FF
#define S_MAXRESAMMO    0
#define M_MAXCLIPAMMO   0x0000FF00
#define S_MAXCLIPAMMO   8
#define F_ISAUTO        0x00010000
#define F_ISBULLET      0x00020000
#define F_NOSTRIP       0x00040000
#define F_ISENERGY      0x00080000

#define MAX_ZF_WEAPONS 1100
static ZF_WEAPON_DATA[MAX_ZF_WEAPONS] = {0, ...};

//multi class items
#define ZFWEAP_FRYINGPAN    264
#define ZFWEAP_SAXXY        423
#define ZFWEAP_CONSCIENTIOUSOBJECTOR 474
#define ZFWEAP_FREEDOMSTAFF 880
#define ZFWEAP_MEMORYMAKER  954
#define ZFWEAP_HAMSHANK     1013
#define ZFWEAP_BATOUTTAHELL 939
#define ZFWEAP_GOLD_PAN     1071

// Scout
#define ZFWEAP_SCATTERGUN   13
#define ZFWEAP_FORCEANATURE 45
#define ZFWEAP_SHORTSTOP    220
#define ZFWEAP_SODAPOPPER   448
#define ZFWEAP_FESTIVESCATTERGUN 669
#define ZFWEAP_BABYFACEBLASTER   772
#define ZFWEAP_SILVER_SCATTERGUN 799
#define ZFWEAP_GOLD_SCATTERGUN   808
#define ZFWEAP_RUST_SCATTERGUN   888
#define ZFWEAP_BLOOD_SCATTERGUN  897
#define ZFWEAP_CARBONADO_SCATTERGUN 906
#define ZFWEAP_DIAMOND_SCATTERGUN   915
#define ZFWEAP_SILVER_II_SCATTERGUN 964
#define ZFWEAP_GOLD_II_SCATTERGUN   973
#define ZFWEAP_FESTIVEFORCEANATURE 1078
#define ZFWEAP_SCOUTPISTOL  23
#define ZFWEAP_BONK         46
#define ZFWEAP_CRITACOLA    163
#define ZFWEAP_MADMILK      222
#define ZFWEAP_WINGER       449
#define ZFWEAP_POCKETPISTOL 773
#define ZFWEAP_FLYINGGUILLOTINE      812
#define ZFWEAP_GEN_FLYINGGUILLOTINE  833
#define ZFWEAP_BAT          0
#define ZFWEAP_SANDMAN      44
#define ZFWEAP_HOLYMACKAREL 221
#define ZFWEAP_CANDYCANE    317
#define ZFWEAP_BOSTONBASHER 325 
#define ZFWEAP_SUNONASTICK  349
#define ZFWEAP_FANOWAR      355
#define ZFWEAP_ATOMIZER     450
#define ZFWEAP_THREERUNEBLADE     452
#define ZFWEAP_UNARMEDCOMBAT      572
#define ZFWEAP_WRAPASSASSIN 648
#define ZFWEAP_FESTIVEBAT   660
#define ZFWEAP_FESTIVEMACKAREL    999
#define ZFWEAP_SCATTERGUN_UPGRADE 200
#define ZFWEAP_PISTOL_UPGRADE     209 // Scout, Engineer
#define ZFWEAP_BAT_UPGRADE        190

// Sniper
#define ZFWEAP_SNIPERRIFLE   14
#define ZFWEAP_HUNTSMAN      56
#define ZFWEAP_SYDNEYSLEEPER 230
#define ZFWEAP_BAZAARBARGAIN 402
#define ZFWEAP_MACHINA       526
#define ZFWEAP_FESTIVESNIPERRIFLE 664
#define ZFWEAP_HEATMAKER     752
#define ZFWEAP_AWPERHAND     851
#define ZFWEAP_SILVER_RIFLE  792
#define ZFWEAP_GOLD_RIFLE    801
#define ZFWEAP_RUST_RIFLE    881
#define ZFWEAP_BLOOD_RIFLE   890
#define ZFWEAP_CARBONADO_RIFLE   899
#define ZFWEAP_DIAMOND_RIFLE     908
#define ZFWEAP_SILVER_II_RIFLE   957
#define ZFWEAP_GOLD_II_RIFLE     966
#define ZFWEAP_FESTIVEHUNTSMAN   1005
#define ZFWEAP_SMG           16
#define ZFWEAP_RAZORBACK     57
#define ZFWEAP_JARATE        58
#define ZFWEAP_FESTIVEJARATE 1083
#define ZFWEAP_DANGERSHIELD  231
#define ZFWEAP_COZYCAMPER    642
#define ZFWEAP_CLEANCARBINE  751
#define ZFWEAP_KUKRI         3
#define ZFWEAP_SHIV          171
#define ZFWEAP_BUSHWACKA     232
#define ZFWEAP_SHAHANSHAH    401
#define ZFWEAP_SNIPERRIFLE_UPGRADE 201
#define ZFWEAP_SMG_UPGRADE         203
#define ZFWEAP_KUKRI_UPGRADE       193

// Soldier  
#define ZFWEAP_ROCKETLAUNCHER  18
#define ZFWEAP_DIRECTHIT       127
#define ZFWEAP_BLACKBOX        228
#define ZFWEAP_ROCKETJUMPER    237
#define ZFWEAP_LIBERTYLAUNCHER 414
#define ZFWEAP_COWMANGLER5000  441
#define ZFWEAP_ORIGINAL        513
#define ZFWEAP_FESTIVEROCKETLAUNCHER 658
#define ZFWEAP_BEGGERSBAZOOKA        730
#define ZFWEAP_SILVER_ROCKETLAUNCHER 800
#define ZFWEAP_GOLD_ROCKETLAUNCHER   809
#define ZFWEAP_RUST_ROCKETLAUNCHER   889
#define ZFWEAP_BLOOD_ROCKETLAUNCHER  898
#define ZFWEAP_CARBONADO_ROCKETLAUNCHER 907
#define ZFWEAP_DIAMOND_ROCKETLAUNCHER   916
#define ZFWEAP_SILVER_II_ROCKETLAUNCHER 965
#define ZFWEAP_GOLD_II_ROCKETLAUNCHER   974
#define ZFWEAP_FESTIVEBLACKBOX    1085
#define ZFWEAP_SOLDIERSHOTGUN     10
#define ZFWEAP_BUFFBANNER         129
#define ZFWEAP_GUNBOATS           133
#define ZFWEAP_BATTALIONSBACKUP   226
#define ZFWEAP_CONCHEROR          354
#define ZFWEAP_RESERVESHOOTER     415
#define ZFWEAP_RIGHTEOUSBISON     442
#define ZFWEAP_MANTREADS          444
#define ZFWEAP_FESTIVEBUFFBANNER  1001
#define ZFWEAP_SHOVEL          6
#define ZFWEAP_EQUALIZER       128
#define ZFWEAP_PAINTRAIN       154 // Soldier, Demoman
#define ZFWEAP_HALFZATOICHI    357 // Soldier, Demoman
#define ZFWEAP_MARKETGARDENER  416
#define ZFWEAP_DISCIPLINARY    447
#define ZFWEAP_ESCAPEPLAN      775
#define ZFWEAP_ROCKETLAUNCHER_UPGRADE  205
#define ZFWEAP_SHOTGUN_UPGRADE        199 // Soldier, Pyro, Heavy, Engineer
#define ZFWEAP_SHOVEL_UPGRADE          196

// Demoman
#define ZFWEAP_GRENADELAUNCHER    19
#define ZFWEAP_LOCHNLOAD          308
#define ZFWEAP_ALIBABASWEEBOOTIES 405
#define ZFWEAP_BOOTLEGGER         608
#define ZFWEAP_LOOSECANNON        996
#define ZFWEAP_FESTIVEGRENADELAUNCHER  1007
#define ZFWEAP_STICKYLAUNCHER          20
#define ZFWEAP_SCOTTISHRESISTANCE      130
#define ZFWEAP_CHARGINTARGE            131
#define ZFWEAP_STICKYJUMPER            265
#define ZFWEAP_SPLENDIDSCREEN          406
#define ZFWEAP_FESTIVESTICKYLAUNCHER   661
#define ZFWEAP_SILVER_STICKYLAUNCHER   797
#define ZFWEAP_GOLD_STICKYLAUNCHER     806
#define ZFWEAP_RUST_STICKYLAUNCHER     886
#define ZFWEAP_BLOOD_STICKYLAUNCHER    895
#define ZFWEAP_CARBONADO_STICKYLAUNCHER     904
#define ZFWEAP_DIAMOND_STICKYLAUNCHER       916
#define ZFWEAP_SILVER_II_STICKYLAUNCHER     962
#define ZFWEAP_GOLD_II_STICKYLAUNCHER       971
#define ZFWEAP_BOTTLE             1
#define ZFWEAP_EYELANDER          132
#define ZFWEAP_FESTIVEEYELANDER   1082
#define ZFWEAP_SKULLCUTTER        172
#define ZFWEAP_HHHHEADTAKER       266
#define ZFWEAP_ULLAPOOLCABER      307
#define ZFWEAP_CLAIDHEAMOHMOR     327
#define ZFWEAP_PERSIANPERSUADER   404
#define ZFWEAP_NESSIESNINEIRON    482
#define ZFWEAP_SCOTTISHHANDSHAKE  609
#define ZFWEAP_GRENADELAUNCHER_UPGRADE 206
#define ZFWEAP_STICKYLAUNCHER_UPGRADE  207
#define ZFWEAP_BOTTLE_UPGRADE          191

// Medic
#define ZFWEAP_SYRINGEGUN               17
#define ZFWEAP_BLUTSAUGER               36
#define ZFWEAP_CRUSADERSCROSSBOW        305
#define ZFWEAP_FESTIVECRUSADERSCROSSBOW 1079
#define ZFWEAP_OVERDOSE          412
#define ZFWEAP_MEDIGUN           29
#define ZFWEAP_KRITZKRIEG        35
#define ZFWEAP_QUICKFIX          411
#define ZFWEAP_FESTIVEMEDIGUN    663
#define ZFWEAP_SILVER_MEDIGUN    796
#define ZFWEAP_GOLD_MEDIGUN      805
#define ZFWEAP_RUST_MEDIGUN      885
#define ZFWEAP_BLOOD_MEDIGUN     894
#define ZFWEAP_CARBONADO_MEDIGUN    903
#define ZFWEAP_DIAMOND_MEDIGUN      912
#define ZFWEAP_SILVER_II_MEDIGUN    961
#define ZFWEAP_GOLD_II_MEDIGUN      970
#define ZFWEAP_VACCINATOR         998
#define ZFWEAP_BONESAW            8
#define ZFWEAP_UBERSAW            37
#define ZFWEAP_VITASAW            173
#define ZFWEAP_AMPUTATOR          304
#define ZFWEAP_SOLEMNVOW          413
#define ZFWEAP_SYRINGEGUN_UPGRADE 204
#define ZFWEAP_MEDIGUN_UPGRADE    211
#define ZFWEAP_BONESAW_UPGRADE    198

// Heavy
#define ZFWEAP_SASHA          15
#define ZFWEAP_NATASCHA       41
#define ZFWEAP_IRONCURTAIN    298
#define ZFWEAP_BRASSBEAST     312
#define ZFWEAP_TOMISLAV       424
#define ZFWEAP_FESTIVEMINIGUN 654
#define ZFWEAP_SILVER_SASHA   793
#define ZFWEAP_GOLD_SASHA     802
#define ZFWEAP_HUOHEATMAKER      811
#define ZFWEAP_GEN_HEATMALER  832
#define ZFWEAP_DEFLECTOR      850
#define ZFWEAP_RUST_SASHA     882
#define ZFWEAP_BLOOD_SASHA    891
#define ZFWEAP_CARBONADO_SASHA   900
#define ZFWEAP_DIAMOND_SASHA     909
#define ZFWEAP_SILVER_II_SASHA   958
#define ZFWEAP_GOLD_II_SASHA     867
#define ZFWEAP_HEAVYSHOTGUN    11
#define ZFWEAP_SANDVICH        42
#define ZFWEAP_DALOKOHSBAR     159
#define ZFWEAP_BUFFALOSTEAK    311
#define ZFWEAP_FAMILYBUSINESS  425
#define ZFWEAP_FISHCAKE        433
#define ZFWEAP_ROBOSANDVICH    863
#define ZFWEAP_FESTIVESANDVICH 1002
#define ZFWEAP_FISTS           5
#define ZFWEAP_KGB             43
#define ZFWEAP_GRU             239
#define ZFWEAP_FESTIVEGRU      1084
#define ZFWEAP_WARRIORSSPIRIT  310
#define ZFWEAP_FISTSOFSTEEL    331
#define ZFWEAP_EVICTIONNOTICE  426
#define ZFWEAP_HOLIDAYPUNCH    656
#define ZFWEAP_APOCOFISTS      587
#define ZFWEAP_SASHA_UPGRADE   202
#define ZFWEAP_FISTS_UPGRADE   195

// Pyro
#define ZFWEAP_FLAMETHROWER    21
#define ZFWEAP_BACKBURNER      40
#define ZFWEAP_DEGREASER       215
#define ZFWEAP_PHLOGISTINATOR  594
#define ZFWEAP_FESTIVEFLAMETHROWER  659
#define ZFWEAP_RAINBLOWER           741
#define ZFWEAP_SILVER_FLAMETHROWER  798
#define ZFWEAP_GOLD_FLAMETHROWER    807
#define ZFWEAP_RUST_FLAMETHROWER    887
#define ZFWEAP_BLOOD_FLAMETHROWER        896
#define ZFWEAP_CARBONADO_FLAMETHROWER    905
#define ZFWEAP_DIAMOND_FLAMETHROWER      914
#define ZFWEAP_SILVER_II_FLAMETHROWER    963
#define ZFWEAP_GOLD_II_FLAMETHROWER      972
#define ZFWEAP_PYROSHOTGUN     12
#define ZFWEAP_FLAREGUN        39
#define ZFWEAP_FESTIVEFLAREGUN 1081
#define ZFWEAP_DETONATOR       351
#define ZFWEAP_MANMELTER       595
#define ZFWEAP_SCORCHSHOT      740
#define ZFWEAP_FIREAXE         2
#define ZFWEAP_AXTINGUISHER    38
#define ZFWEAP_HOMEWRECKER     153
#define ZFWEAP_POWERJACK       214
#define ZFWEAP_BACKSCRATCHER   326
#define ZFWEAP_VOLCANOFRAGMENT 348
#define ZFWEAP_POSTALPUMMELER  457
#define ZFWEAP_MAUL            466
#define ZFWEAP_THIRDDEGREE     593
#define ZFWEAP_LOLLICHOP       739
#define ZFWEAP_NEONANNIHILATOR         813
#define ZFWEAP_GEN_NEONANNIHILATOR     834
#define ZFWEAP_FLAMETHROWER_UPGRADE    208
#define ZFWEAP_FIREAXE_UPGRADE         192

// Spy
#define ZFWEAP_REVOLVER       24
#define ZFWEAP_AMBASSADOR     61
#define ZFWEAP_BIGKILL        161
#define ZFWEAP_LETRANGER      224
#define ZFWEAP_ENFORCER       460
#define ZFWEAP_DIAMONDBACK    525
#define ZFWEAP_FESTIVEAMBASSADOR 1006
#define ZFWEAP_KNIFE             4
#define ZFWEAP_ETERNALREWARD     225
#define ZFWEAP_CONNIVERSKUNAI    356
#define ZFWEAP_BIGEARNER         461
#define ZFWEAP_WANGAPRICK        574
#define ZFWEAP_SHARPDRESSER      638
#define ZFWEAP_SPYCICLE          649
#define ZFWEAP_FESTIVEKNIFE      665
#define ZFWEAP_BLACKROSE         727
#define ZFWEAP_SILVER_KNIFE      794
#define ZFWEAP_GOLD_KNIFE        803
#define ZFWEAP_RUST_KNIFE        883
#define ZFWEAP_BLOOD_KNIFE       892
#define ZFWEAP_CARBONADO_KNIFE   901
#define ZFWEAP_DIAMOND_KNIFE     910
#define ZFWEAP_SILVER_II_KNIFE   959
#define ZFWEAP_GOLD_II_KNIFE     968
#define ZFWEAP_INVISWATCH        30
#define ZFWEAP_DEADRINGER        59
#define ZFWEAP_CLOAKANDDAGGER    60
#define ZFWEAP_TTGWATCH          297
#define ZFWEAP_QUAKENBIRDT       947
#define ZFWEAP_REVOLVER_UPGRADE     210
#define ZFWEAP_KNIFE_UPGRADE        194
#define ZFWEAP_INVISWATCH_UPGRADE   212

// Engineer
#define ZFWEAP_ENGINEERSHOTGUN     9
#define ZFWEAP_FRONTIERJUSTICE     141
#define ZFWEAP_WIDOWMAKER          527
#define ZFWEAP_POMSON6000          588
#define ZFWEAP_RESCUERANGER        997
#define ZFWEAP_FESTIVEFRONTIERJUSTICE   1004
#define ZFWEAP_ENGINEERPISTOL           22
#define ZFWEAP_LUGERMORPH1              160 // Scout, Engineer
#define ZFWEAP_LUGERMORPH2              294 // Scout, Engineer
#define ZFWEAP_WRANGLER                 140
#define ZFWEAP_FESTIVEWRANGLER          1086
#define ZFWEAP_SHORTCIRCUIT             528
#define ZFWEAP_WRENCH                   7
#define ZFWEAP_GUNSLINGER               142
#define ZFWEAP_SOUTHERNHOSPITALITY      155
#define ZFWEAP_GOLDENWRENCH        169
#define ZFWEAP_JAG                 329
#define ZFWEAP_EUREKAEFFECT        589
#define ZFWEAP_FESTIVEWRENCH       662
#define ZFWEAP_SILVER_WRENCH       795
#define ZFWEAP_GOLD_WRENCH         804
#define ZFWEAP_RUST_WRENCH         884
#define ZFWEAP_BLOOD_WRENCH        893
#define ZFWEAP_CARBONADO_WRENCH    902
#define ZFWEAP_DIAMOND_WRENCH      911
#define ZFWEAP_SILVER_II_WRENCH    960
#define ZFWEAP_GOLD_II_WRENCH      969
#define ZFWEAP_BUILDPDA            25
#define ZFWEAP_BUILDPDA_UPGRADE    737
#define ZFWEAP_DESTROYPDA          26
#define ZFWEAP_WRENCH_UPGRADE      197
  
//
// Offsets
//
static oActiveWeapon;
static oCloakMeter;
static oMaxspeed;
static oResAmmo[3];

static oClipAmmo;
static oNextPriAttack;
static oNextSecAttack;

//
// ZF Class Objects
//
static const TFClassType:ZF_SURVIVORS[6] = {
  TFClass_Sniper, TFClass_Soldier, TFClass_DemoMan, 
  TFClass_Medic,  TFClass_Pyro,    TFClass_Engineer};
static const TFClassType:ZF_ZOMBIES[3] = {
  TFClass_Scout,  TFClass_Heavy,   TFClass_Spy};
static const ZF_VALIDSURVIVOR[10] = {0,0,1,1,1,1,0,1,0,1};
static const ZF_VALIDZOMBIE[10]   = {0,1,0,0,0,0,1,0,1,0};

//
// ZF Team / Round State
//
enum ZFRoundState
{
  RoundInit1,
  RoundInit2,
  RoundGrace,
  RoundActive,
  RoundPost
}
static ZFRoundState:zf_roundState = RoundInit1;
static zf_zomTeam = _:TFTeam_Blue;
static zf_surTeam = _:TFTeam_Red;

////////////////////////////////////////////////////////////
//
// Util Init
//
////////////////////////////////////////////////////////////
utilBaseInit()
{
  //
  // Initialize offsets.
  //
  oActiveWeapon = FindSendPropInfo("CTFPlayer", "m_hActiveWeapon");
  oCloakMeter   = FindSendPropInfo("CTFPlayer", "m_flCloakMeter");
  oMaxspeed     = FindSendPropInfo("CTFPlayer", "m_flMaxspeed");  
  oResAmmo[0]   = FindSendPropInfo("CTFPlayer", "m_iAmmo") + 4;
  oResAmmo[1]   = FindSendPropInfo("CTFPlayer", "m_iAmmo") + 8;
  oResAmmo[2]   = FindSendPropInfo("CTFPlayer", "m_iAmmo") + 12;

  oClipAmmo      = FindSendPropInfo("CBaseCombatWeapon", "m_iClip1");
  oNextPriAttack = FindSendPropInfo("CBaseCombatWeapon", "m_flNextPrimaryAttack");
  oNextSecAttack = FindSendPropInfo("CBaseCombatWeapon", "m_flNextSecondaryAttack"); 

  //
  // Initialize weapon data.
  //
  // Multiple Class items
  ZF_WEAPON_DATA[ZFWEAP_CONSCIENTIOUSOBJECTOR] 	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SAXXY]            		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FREEDOMSTAFF]     		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_MEMORYMAKER]      		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_HAMSHANK]         		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BATOUTTAHELL]     		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FRYINGPAN]        		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GOLD_PAN]        		= F_NOSTRIP;
  
  // Scout
  ZF_WEAPON_DATA[ZFWEAP_SCATTERGUN]   		   = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FORCEANATURE] 		   = F_ISBULLET          | (2 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEFORCEANATURE]   = F_ISBULLET          | (2 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SHORTSTOP]    		   = F_ISBULLET          | (4 << 8) | (36 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SODAPOPPER]            = F_ISBULLET          | (2 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVESCATTERGUN]     = F_ISBULLET     	 | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BABYFACEBLASTER]       = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_SCATTERGUN]     = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_GOLD_SCATTERGUN]       = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_RUST_SCATTERGUN]       = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_SCATTERGUN]      = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_SCATTERGUN]  = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_SCATTERGUN]    = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_SCATTERGUN]  = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_SCATTERGUN]    = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SCOUTPISTOL]  		   = F_ISAUTO|F_ISBULLET | (12 << 8) | (200 << 0); // To fix Engineers using Strange Pistol
  ZF_WEAPON_DATA[ZFWEAP_WINGER]       		   = F_ISAUTO|F_ISBULLET | (5 << 8) | (36 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BONK]         		   = F_NOSTRIP 			 | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_CRITACOLA]    		   = F_NOSTRIP 			 | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_MADMILK]      		   = F_NOSTRIP 			 | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_POCKETPISTOL] 		   = F_ISAUTO|F_ISBULLET | (12 << 8) | (36 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FLYINGGUILLOTINE]      = F_NOSTRIP 			 | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_GEN_FLYINGGUILLOTINE]  = F_NOSTRIP 			 | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BAT]          		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SANDMAN]     		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_HOLYMACKAREL] 		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_CANDYCANE]    		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BOSTONBASHER] 		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SUNONASTICK]  		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FANOWAR]      		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_ATOMIZER]     		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_THREERUNEBLADE]        = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_UNARMEDCOMBAT]         = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_WRAPASSASSIN]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEBAT]            = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEMACKAREL]       = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SCATTERGUN_UPGRADE]    = ZF_WEAPON_DATA[ZFWEAP_SCATTERGUN];  
  ZF_WEAPON_DATA[ZFWEAP_PISTOL_UPGRADE]        = ZF_WEAPON_DATA[ZFWEAP_SCOUTPISTOL];
  ZF_WEAPON_DATA[ZFWEAP_BAT_UPGRADE]           = ZF_WEAPON_DATA[ZFWEAP_BAT];

  // Sniper
  ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE]   			= F_ISBULLET          | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_HUNTSMAN]     	 		=                       (1 << 8) | (12 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SYDNEYSLEEPER] 			= F_ISBULLET          | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BAZAARBARGAIN] 			= F_ISBULLET          | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_MACHINA]       			= F_ISBULLET          | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVESNIPERRIFLE] 	= F_ISBULLET     | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_AWPERHAND]          	= F_ISBULLET          | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_HEATMAKER]          	= F_ISBULLET          | (0 << 8) | (25 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_RIFLE]       	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_RIFLE]         	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_RUST_RIFLE]         	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_RIFLE]        	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_RIFLE]    	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_RIFLE]      	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_RIFLE]    	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_RIFLE]      	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEHUNTSMAN]    	=                       (1 << 8) | (12 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SMG]           			= F_ISAUTO|F_ISBULLET | (25 << 8) | (75 << 0);
  ZF_WEAPON_DATA[ZFWEAP_RAZORBACK]     			= F_NOSTRIP           | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_JARATE]        			= F_NOSTRIP           | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEJARATE]        	= F_NOSTRIP           | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DANGERSHIELD]  			= F_NOSTRIP           | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_COZYCAMPER]    			= F_NOSTRIP           | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_CLEANCARBINE]  			= F_ISAUTO|F_ISBULLET | (20 << 8) | (75 << 0);
  ZF_WEAPON_DATA[ZFWEAP_KUKRI]         			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SHIV]         	 		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BUSHWACKA]     			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SHAHANSHAH]    			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE_UPGRADE] 	= ZF_WEAPON_DATA[ZFWEAP_SNIPERRIFLE];
  ZF_WEAPON_DATA[ZFWEAP_SMG_UPGRADE]         	= ZF_WEAPON_DATA[ZFWEAP_SMG]; 
  ZF_WEAPON_DATA[ZFWEAP_KUKRI_UPGRADE]       	= ZF_WEAPON_DATA[ZFWEAP_KUKRI];
  
  // Soldier
  ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER]  			=              (4 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DIRECTHIT]       			=              (4 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BLACKBOX]        			=              (3 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEBLACKBOX]        	=              (3 << 8) | (20 << 0);
  //ZF_WEAPON_DATA[ZFWEAP_ROCKETJUMPER]    			=              (4 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_ROCKETJUMPER]    			= 0;			// banned
  ZF_WEAPON_DATA[ZFWEAP_LIBERTYLAUNCHER] 			=              (3 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_COWMANGLER5000]  			= F_ISENERGY | (0 << 8) | (5 << 0);
  ZF_WEAPON_DATA[ZFWEAP_ORIGINAL]        			=              (4 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEROCKETLAUNCHER]     	=        (4 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BEGGERSBAZOOKA]            	=        (3 << 8) | (20 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_ROCKETLAUNCHER]     	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_ROCKETLAUNCHER]      	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_RUST_ROCKETLAUNCHER]       	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_ROCKETLAUNCHER]      	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_ROCKETLAUNCHER]  	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_ROCKETLAUNCHER]    	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_ROCKETLAUNCHER]  	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_ROCKETLAUNCHER]    	=    ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_SOLDIERSHOTGUN]     		= F_ISBULLET | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BUFFBANNER]         		= F_NOSTRIP  | (0 << 8) | (0 << 0);
  //ZF_WEAPON_DATA[ZFWEAP_GUNBOATS]         		= F_NOSTRIP  | (0 << 8) | (0 << 0); no need?
  ZF_WEAPON_DATA[ZFWEAP_BATTALIONSBACKUP]   		= F_NOSTRIP  | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_CONCHEROR]          		= F_NOSTRIP  | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_RESERVESHOOTER]     		= F_ISBULLET | (3 << 8) | (32 << 0); // Soldier, Pyro
  //ZF_WEAPON_DATA[ZFWEAP_MANTREADS]        		= F_NOSTRIP  | (0 << 8) | (0 << 0); no need?
  ZF_WEAPON_DATA[ZFWEAP_RIGHTEOUSBISON]     		= F_ISENERGY | (0 << 8) | (4 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEBUFFBANNER]  		= F_NOSTRIP  | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SHOVEL]         			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_EQUALIZER]      			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_PAINTRAIN]      			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_HALFZATOICHI]    			= F_NOSTRIP; // Demoman, Soldier
  ZF_WEAPON_DATA[ZFWEAP_MARKETGARDENER]  			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_DISCIPLINARY]    			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_ESCAPEPLAN]      			= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER_UPGRADE] 	= ZF_WEAPON_DATA[ZFWEAP_ROCKETLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_SHOTGUN_UPGRADE]        	= ZF_WEAPON_DATA[ZFWEAP_SOLDIERSHOTGUN];  
  ZF_WEAPON_DATA[ZFWEAP_SHOVEL_UPGRADE]         	= ZF_WEAPON_DATA[ZFWEAP_SHOVEL];
  
  // Demoman
  ZF_WEAPON_DATA[ZFWEAP_GRENADELAUNCHER]           =             (4 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_LOCHNLOAD]                 =             (2 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_ALIBABASWEEBOOTIES]        = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BOOTLEGGER]                = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_LOOSECANNON]               =             (4 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEGRENADELAUNCHER]    =             (4 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER]            =             (8 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SCOTTISHRESISTANCE]        =             (8 << 8) | (36 << 0);
  ZF_WEAPON_DATA[ZFWEAP_CHARGINTARGE]              = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_STICKYJUMPER]              = 0;			//banned
  //ZF_WEAPON_DATA[ZFWEAP_STICKYJUMPER]              =             (8 << 8) | (72 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SPLENDIDSCREEN]        	   = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVESTICKYLAUNCHER]     =          (8 << 8) | (36 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_STICKYLAUNCHER]     = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_STICKYLAUNCHER]       = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_RUST_STICKYLAUNCHER]       = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_STICKYLAUNCHER]      = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_STICKYLAUNCHER]  = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_STICKYLAUNCHER]    = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_STICKYLAUNCHER]  = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_STICKYLAUNCHER]    = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_BOTTLE]             	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_EYELANDER]          	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEEYELANDER]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SKULLCUTTER]        	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_HHHHEADTAKER]       	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_ULLAPOOLCABER]     		   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_CLAIDHEAMOHMOR]     	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_PERSIANPERSUADER]   	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_NESSIESNINEIRON]    	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SCOTTISHHANDSHAKE]  	   = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GRENADELAUNCHER_UPGRADE]   = ZF_WEAPON_DATA[ZFWEAP_GRENADELAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER_UPGRADE]    = ZF_WEAPON_DATA[ZFWEAP_STICKYLAUNCHER];
  ZF_WEAPON_DATA[ZFWEAP_BOTTLE_UPGRADE]            = ZF_WEAPON_DATA[ZFWEAP_BOTTLE];
  
  // Medic
  ZF_WEAPON_DATA[ZFWEAP_SYRINGEGUN]                = F_ISAUTO  | (40 << 8) | (150 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BLUTSAUGER]                = F_ISAUTO  | (40 << 8) | (150 << 0);
  ZF_WEAPON_DATA[ZFWEAP_CRUSADERSCROSSBOW]         =             (1 << 8) | (38 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVECRUSADERSCROSSBOW]  =             (1 << 8) | (38 << 0);
  ZF_WEAPON_DATA[ZFWEAP_OVERDOSE]           = F_ISAUTO  | (40 << 8) | (150 << 0);
  ZF_WEAPON_DATA[ZFWEAP_MEDIGUN]            = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_KRITZKRIEG]         = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_QUICKFIX]           = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEMEDIGUN]     = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_MEDIGUN]     = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_MEDIGUN]       = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_RUST_MEDIGUN]       = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_MEDIGUN]      = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_MEDIGUN]  = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_MEDIGUN]    = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_MEDIGUN]  = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_MEDIGUN]    = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_VACCINATOR]         = F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BONESAW]            = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_UBERSAW]            = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_VITASAW]            = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_AMPUTATOR]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SOLEMNVOW]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SYRINGEGUN_UPGRADE] = ZF_WEAPON_DATA[ZFWEAP_SYRINGEGUN];
  ZF_WEAPON_DATA[ZFWEAP_MEDIGUN_UPGRADE]    = ZF_WEAPON_DATA[ZFWEAP_MEDIGUN];
  ZF_WEAPON_DATA[ZFWEAP_BONESAW_UPGRADE]    = ZF_WEAPON_DATA[ZFWEAP_BONESAW];
  
  // Heavy
  ZF_WEAPON_DATA[ZFWEAP_SASHA]          	= F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_NATASCHA]       	= F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_IRONCURTAIN]    	= F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BRASSBEAST]     	= F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_TOMISLAV]       	= F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEMINIGUN] 	= F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SILVER_SASHA]       = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_SASHA]         = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_HUOHEATMAKER]       = F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_GEN_HEATMALER]      = F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DEFLECTOR]          = F_ISAUTO|F_ISBULLET | (0 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_RUST_SASHA]         = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_SASHA]        = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_SASHA]    = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_SASHA]      = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_SASHA]    = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_SASHA]      = ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_HEAVYSHOTGUN]     	= F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SANDVICH]         	= F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DALOKOHSBAR]      	= F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BUFFALOSTEAK]     	= F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FAMILYBUSINESS]   	= F_ISBULLET          | (8 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FISHCAKE]         	= F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_ROBOSANDVICH]     	= F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVESANDVICH]  	= F_NOSTRIP | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FISTS]            	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_KGB]              	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GRU]              	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEGRU]         = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_WARRIORSSPIRIT]   	= F_NOSTRIP; // speed penalty and health penalty
  ZF_WEAPON_DATA[ZFWEAP_FISTSOFSTEEL]    	= F_NOSTRIP; // speed penalty
  ZF_WEAPON_DATA[ZFWEAP_EVICTIONNOTICE]   	= F_NOSTRIP; // health penalty
  ZF_WEAPON_DATA[ZFWEAP_HOLIDAYPUNCH]    	= F_NOSTRIP; // speed and health penalty
  ZF_WEAPON_DATA[ZFWEAP_APOCOFISTS]      	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SASHA_UPGRADE]   	= ZF_WEAPON_DATA[ZFWEAP_SASHA];
  ZF_WEAPON_DATA[ZFWEAP_FISTS_UPGRADE]    	= ZF_WEAPON_DATA[ZFWEAP_FISTS];
  
  // Pyro
  ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER]    		= F_ISAUTO   | (0 << 8) | (125 << 0); // Normal limit 200
  ZF_WEAPON_DATA[ZFWEAP_BACKBURNER]      		= F_ISAUTO   | (0 << 8) | (125 << 0); // Normal limit 200
  ZF_WEAPON_DATA[ZFWEAP_DEGREASER]      	 	= F_ISAUTO   | (0 << 8) | (125 << 0); // Normal limit 200
  ZF_WEAPON_DATA[ZFWEAP_PHLOGISTINATOR]  		= F_ISAUTO   | (0 << 8) | (125 << 0); // Normal limit 200
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEFLAMETHROWER]    = F_ISAUTO   | (0 << 8) | (125 << 0); // Normal limit 200
  ZF_WEAPON_DATA[ZFWEAP_RAINBLOWER]             = F_ISAUTO   | (0 << 8) | (125 << 0); // Normal limit 200
  ZF_WEAPON_DATA[ZFWEAP_SILVER_FLAMETHROWER]    = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_FLAMETHROWER]      = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_RUST_FLAMETHROWER]      = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_FLAMETHROWER]     = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_FLAMETHROWER] = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_FLAMETHROWER]   = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_FLAMETHROWER] = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_FLAMETHROWER]   = ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_PYROSHOTGUN]     		= F_ISBULLET | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FLAREGUN]        		=              (0 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEFLAREGUN]        =              (0 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DETONATOR]       		=              (0 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_MANMELTER]       		= F_NOSTRIP  | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SCORCHSHOT]      		=              (0 << 8) | (16 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FIREAXE]         		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_AXTINGUISHER]    		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_HOMEWRECKER]     		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_POWERJACK]       		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BACKSCRATCHER]   		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_VOLCANOFRAGMENT] 		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_POSTALPUMMELER]  		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_MAUL]            		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_THIRDDEGREE]     		= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_LOLLICHOP]       	  	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_NEONANNIHILATOR]      	= F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GEN_NEONANNIHILATOR]  	= ZF_WEAPON_DATA[ZFWEAP_NEONANNIHILATOR];
  ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER_UPGRADE] 	= ZF_WEAPON_DATA[ZFWEAP_FLAMETHROWER];
  ZF_WEAPON_DATA[ZFWEAP_FIREAXE_UPGRADE]      	= ZF_WEAPON_DATA[ZFWEAP_FIREAXE];
  
  // Spy
  ZF_WEAPON_DATA[ZFWEAP_REVOLVER]      	 	= F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_AMBASSADOR]    	 	= F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_BIGKILL]        	= F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_LETRANGER]      	= F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_ENFORCER]       	= F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_DIAMONDBACK]    	= F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEAMBASSADOR]  = F_ISBULLET | (6 << 8) | (24 << 0);
  ZF_WEAPON_DATA[ZFWEAP_KNIFE]              = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_ETERNALREWARD]      = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_CONNIVERSKUNAI]     = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BIGEARNER]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_WANGAPRICK]         = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SHARPDRESSER]       = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SPYCICLE]           = 0; // Banned due to glitches/problems
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEKNIFE]       = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BLACKROSE]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SILVER_KNIFE]       = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GOLD_KNIFE]         = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_RUST_KNIFE]         = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_KNIFE]        = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_KNIFE]    = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_KNIFE]      = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_KNIFE]    = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_KNIFE]      = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_INVISWATCH]         = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_DEADRINGER]         = 0;		 // banned 
  ZF_WEAPON_DATA[ZFWEAP_CLOAKANDDAGGER]     = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_TTGWATCH]           = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_QUAKENBIRDT]        = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_REVOLVER_UPGRADE]   = ZF_WEAPON_DATA[ZFWEAP_REVOLVER];
  ZF_WEAPON_DATA[ZFWEAP_KNIFE_UPGRADE]      = ZF_WEAPON_DATA[ZFWEAP_KNIFE];
  ZF_WEAPON_DATA[ZFWEAP_INVISWATCH_UPGRADE] = ZF_WEAPON_DATA[ZFWEAP_INVISWATCH];
    
  // Engineer
  ZF_WEAPON_DATA[ZFWEAP_ENGINEERSHOTGUN]    	 = F_ISBULLET          | (6 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FRONTIERJUSTICE]     	 = F_ISBULLET          | (3 << 8) | (32 << 0);
  ZF_WEAPON_DATA[ZFWEAP_WIDOWMAKER]          	 = F_ISBULLET          | (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_POMSON6000]          	 = F_ISENERGY          | (0 << 8) | (4 << 0);
  ZF_WEAPON_DATA[ZFWEAP_RESCUERANGER]        	 = F_ISBULLET          | (6 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEFRONTIERJUSTICE]  = F_ISBULLET          | (3 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_ENGINEERPISTOL]          = F_ISAUTO|F_ISBULLET | (12 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_LUGERMORPH1]             = F_ISAUTO|F_ISBULLET | (12 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_LUGERMORPH2]             = F_ISAUTO|F_ISBULLET | (12 << 8) | (200 << 0);
  ZF_WEAPON_DATA[ZFWEAP_WRANGLER]                =                       (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEWRANGLER]                =                       (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_SHORTCIRCUIT]            =                       (0 << 8) | (0 << 0);
  ZF_WEAPON_DATA[ZFWEAP_WRENCH]              	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GOLDENWRENCH]        	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GUNSLINGER]          	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SOUTHERNHOSPITALITY] 	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_JAG]                 	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_EUREKAEFFECT]        	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_FESTIVEWRENCH]       	 = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SILVER_WRENCH]           = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GOLD_WRENCH]             = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_RUST_WRENCH]             = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BLOOD_WRENCH]            = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_CARBONADO_WRENCH]        = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_DIAMOND_WRENCH]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_SILVER_II_WRENCH]        = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_GOLD_II_WRENCH]          = F_NOSTRIP;
  ZF_WEAPON_DATA[ZFWEAP_BUILDPDA]                = 0;
  ZF_WEAPON_DATA[ZFWEAP_BUILDPDA_UPGRADE]        = 0;
  ZF_WEAPON_DATA[ZFWEAP_DESTROYPDA]     		 = 0;
  ZF_WEAPON_DATA[ZFWEAP_WRENCH_UPGRADE] 		 = ZF_WEAPON_DATA[ZFWEAP_WRENCH];

}

////////////////////////////////////////////////////////////
//
// Math Utils
//
////////////////////////////////////////////////////////////
stock max(a,b) { return (a > b) ? a : b; }
stock min(a,b) { return (a < b) ? a : b; }
stock Float:fMax(Float:a, Float:b) { return (a > b) ? a : b; }
stock Float:fMin(Float:a, Float:b) { return (a < b) ? a : b; }

////////////////////////////////////////////////////////////
//
// ZF Team Utils
//
////////////////////////////////////////////////////////////
stock zomTeam()
{ return zf_zomTeam; }
stock surTeam()
{ return zf_surTeam; }
stock setZomTeam(team)
{ zf_zomTeam = team; }
stock setSurTeam(team)
{ zf_surTeam = team; }
stock isZom(client)
{ return (GetClientTeam(client) == zf_zomTeam); }
stock isSur(client)
{ return (GetClientTeam(client) == zf_surTeam); }

////////////////////////////////////////////////////////////
//
// Client Validity Utils
//
////////////////////////////////////////////////////////////
stock bool:validClient(client)
{ return (client > 0) && (client <= MaxClients) && IsClientInGame(client); }
stock bool:validSur(client)
{ return (client > 0) && (client <= MaxClients) && IsClientInGame(client) && isSur(client); }
stock bool:validZom(client)
{ return (client > 0) && (client <= MaxClients) && IsClientInGame(client) && isZom(client); }
stock bool:validLivingClient(client)
{ return (client > 0) && (client <= MaxClients) && IsClientInGame(client) && IsPlayerAlive(client); }
stock bool:validLivingSur(client)
{ return (client > 0) && (client <= MaxClients) && IsClientInGame(client) && IsPlayerAlive(client) && isSur(client); }
stock bool:validLivingZom(client)
{ return (client > 0) && (client <= MaxClients) && IsClientInGame(client) && IsPlayerAlive(client) && isZom(client); }

////////////////////////////////////////////////////////////
//
// ZF Class Utils
//
////////////////////////////////////////////////////////////
stock bool:validZombie(TFClassType:class)   
{ return (ZF_VALIDZOMBIE[class] == 1); }
stock bool:validSurvivor(TFClassType:class) 
{ return (ZF_VALIDSURVIVOR[class] == 1); }
stock TFClassType:randomZombie()   
{ return ZF_ZOMBIES[GetRandomInt(0,2)]; }
stock TFClassType:randomSurvivor() 
{ return ZF_SURVIVORS[GetRandomInt(0,5)]; }

stock bool:isEngineer(client)
{ return (TF2_GetPlayerClass(client) == TFClass_Engineer); }
stock bool:isHeavy(client)
{ return (TF2_GetPlayerClass(client) == TFClass_Heavy); }
stock bool:isMedic(client)
{ return (TF2_GetPlayerClass(client) == TFClass_Medic); }
stock bool:isPyro(client)
{ return (TF2_GetPlayerClass(client) == TFClass_Pyro); }
stock bool:isScout(client)
{ return (TF2_GetPlayerClass(client) == TFClass_Scout); }
stock bool:isSpy(client)
{ return (TF2_GetPlayerClass(client) == TFClass_Spy); }

////////////////////////////////////////////////////////////
//
// Map Utils
//
////////////////////////////////////////////////////////////
stock bool:mapIsZF()
{
  decl String:mapname[4];
  GetCurrentMap(mapname, sizeof(mapname));
  return strncmp(mapname, "zf_", 3, false) == 0;
}

stock bool:mapIsPL()
{
  decl String:mapname[4];
  GetCurrentMap(mapname, sizeof(mapname));
  return strncmp(mapname, "pl_", 3, false) == 0;
}

stock bool:mapIsCP()
{
  decl String:mapname[4];
  GetCurrentMap(mapname, sizeof(mapname));
  return strncmp(mapname, "cp_", 3, false) == 0;
}

////////////////////////////////////////////////////////////
//
// Round Utils
//
////////////////////////////////////////////////////////////
stock setRoundState(ZFRoundState:_state)
{ zf_roundState = _state; }

stock ZFRoundState:roundState()
{ return zf_roundState; }

stock endRound(winningTeam)
{
  new index = FindEntityByClassname(-1, "team_control_point_master");
  if(index == -1)
  {   
    index = CreateEntityByName("team_control_point_master");
    DispatchSpawn(index);
  }

  if(index == -1)
  {
    LogError("[ZF] Can't create 'team_control_point_master,' can't end round!");
  }
  else
  {
    AcceptEntityInput(index, "Enable");
    SetVariantInt(winningTeam);
    AcceptEntityInput(index, "SetWinner"); 
  }  
}

////////////////////////////////////////////////////////////
//
// Weapon State Utils
//
////////////////////////////////////////////////////////////
stock activeWeapon(client)
{ return GetEntDataEnt2(client, oActiveWeapon); }

stock activeWeaponId(client)
{
  new weapon = activeWeapon(client);
  return (weapon > 0) ? GetEntProp(weapon, Prop_Send, "m_iItemDefinitionIndex") : -1;
}

stock slotWeaponId(client, slot)
{
  new weapon = GetPlayerWeaponSlot(client, slot);
  return (weapon > 0) ? GetEntProp(weapon, Prop_Send, "m_iItemDefinitionIndex") : -1;
}

stock activeWeaponSlot(client)
{
  new weapon = activeWeapon(client);
  if(weapon > 0)
  {
    for(new i = 0; i < 5; i++)
      if(GetPlayerWeaponSlot(client, i) == weapon) 
        return i;
  }
  return -1;
}

stock bool:isEquipped(client, weaponId)
{
  for(new i = 0; i < 5; i++)
    if(slotWeaponId(client, i) == weaponId)
      return true;
  return false;
}

stock bool:isWielding(client, weaponId)
{ return (activeWeaponId(client) == weaponId); }

stock bool:isWieldingMelee(client)
{ return (activeWeaponSlot(client) == 2); }

stock bool:isWieldingAuto(client)
{
  new weaponId = activeWeaponId(client);
  if(weaponId >= 0)
  {
    if(weaponId >= MAX_ZF_WEAPONS)
      LogError("[ZF] - isWieldingAuto() - Invalid weaponId: %d", weaponId);
    else
      return ((ZF_WEAPON_DATA[weaponId] & F_ISAUTO) != 0);
  }
  return false;
}

stock bool:isWieldingBullet(client)
{  
  new weaponId = activeWeaponId(client);
  if(weaponId >= 0)
  {
    if(weaponId >= MAX_ZF_WEAPONS)
      LogError("[ZF] - isWieldingBullet() - Invalid weaponId: %d", weaponId);
    else
      return ((ZF_WEAPON_DATA[weaponId] & F_ISBULLET) != 0);
  }
  return false;
}

////////////////////////////////////////////////////////////
//
// Weapon Action Utils
//
////////////////////////////////////////////////////////////
stock switchToSlot(client, slot)
{
  new weapon = GetPlayerWeaponSlot(client, slot);
  if(weapon > 0)
    EquipPlayerWeapon(client, weapon);
}

stock stripWeapons(client, bool:keepPri = false)
{
  //
  // Strip weapons.
  // Remove weapon if it exists and F_NOSTRIP flag is not set.
  // Do not remove primary weapons if keepPri flag is set.
  //
  new bool:doStrip;
  new weaponId;
  for(new i = 0; i < 5; i++)
  {
    weaponId = slotWeaponId(client, i);
    if(weaponId > 0)
    {
      if(weaponId >= MAX_ZF_WEAPONS)
      {
        LogError("[ZF] - stripToMelee() - Invalid weaponId: %d", weaponId);
        TF2_RemoveWeaponSlot(client, i);
      }
      else
      {
        doStrip = ((ZF_WEAPON_DATA[weaponId] & F_NOSTRIP) == 0);
        if((i == 0) && keepPri)
          doStrip = false;
        if(doStrip)
          TF2_RemoveWeaponSlot(client, i);
      }
    }
  }

  //
  // Switch to melee slot.
  //
  switchToSlot(client, 2);
}

stock stripWeaponSlot(client, slot)
{
  if(GetPlayerWeaponSlot(client, slot) > 0) 
    TF2_RemoveWeaponSlot(client, slot);
}

stock setWeaponRof(weapon, rateScale)
{
  new Float:factor;
  new Float:tAttack;
  new Float:tEngine;    

  factor = (rateScale <= -100) ? 100.0 : 100 / float(100 + rateScale);
  tEngine = GetGameTime();
  tAttack = (GetEntDataFloat(weapon, oNextPriAttack) - tEngine) * factor;
  SetEntDataFloat(weapon, oNextPriAttack, (tAttack + tEngine), true);
  tAttack = (GetEntDataFloat(weapon, oNextSecAttack) - tEngine) * factor;
  SetEntDataFloat(weapon, oNextSecAttack, (tAttack + tEngine), true);
}

////////////////////////////////////////////////////////////
//
// Weapon Attack/Damage Utils
//
////////////////////////////////////////////////////////////
stock bool:attackWasBackstab(attacker, inflictor, damagetype)
{
  // Backstab attack defined as:
  // + attacker equals inflictor (i.e. not a projectile), AND
  // + attacker is a spy, AND
  // + attacker is wielding a melee weapon, AND
  // + damagetype (masked) equals 0x100000 (which indicates crit, thus backstab, through testing)
  return (attacker == inflictor) && isSpy(attacker) && isWieldingMelee(attacker) && ((damagetype & TF2_DMGTYPE_CRIT) != 0);
}

stock bool:attackWasMelee(attacker, inflictor, damagetype)
{
  // Melee attack defined as:
  // + damagetype includes bludgeon damage, AND
  // + attacker does not equal inflictor (i.e. projectile)
  return attackWasBludgeon(damagetype) && !attackWasProjectile(attacker, inflictor);
}

stock bool:attackWasBullet(attacker, inflictor)
{
  // Bullet attack defined as:
  // + attacker equals inflictor (i.e. not a projectile), AND
  // + attacker is wielding bullet-based weapon
  // OR
  // + inflictor is sentry gun
  return (attacker == inflictor) ? isWieldingBullet(attacker) : entIsSentry(inflictor);
}

stock bool:attackWasProjectile(attacker, inflictor)
{
  // Projectile attack defined as:
  // + attacker does not equal inflictor (i.e. projectile)
  return (attacker != inflictor);
}

stock bool:attackWasSelfFall(inflictor, damagetype)
{
  // Self-fall damage defined as:
  // + inflictor is 0, AND
  // + attackWasFall is true.
  return (inflictor == 0) && attackWasFall(damagetype);
}

stock bool:attackWasBleed(damagetype)
{ return (damagetype == TF2_DMGTYPE_BLEED); }

stock bool:attackWasBludgeon(damagetype)
{ return (damagetype & TF2_DMGTYPE_BLUDGEON) != 0; }

stock bool:attackWasEnvExplosion(damagetype)
{ return (damagetype == TF2_DMGTYPE_EXPLOSIVE); }

stock bool:attackWasExplosive(damagetype)
{ return (damagetype & TF2_DMGTYPE_EXPLOSIVE) != 0; }

stock bool:attackWasFall(damagetype)
{ return (damagetype == TF2_DMGTYPE_FALL); }

stock bool:attackWasFire(damagetype)
{ return (damagetype & TF2_DMGTYPE_FIRE) != 0; } // Note: Does not account for medic syringe gun damage

////////////////////////////////////////////////////////////
//
// Attribute / Flags Utils (Simple)
//
////////////////////////////////////////////////////////////
stock addCondKritz(client, Float:duration)
{ TF2_AddCondition(client, TFCond_Kritzkrieged, duration); }
stock remCondKritz(client)
{ TF2_RemoveCondition(client, TFCond_Kritzkrieged); }

stock bool:isSlowed(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Slowed); }
stock bool:isSpeedBuffed(client)
{ return TF2_IsPlayerInCondition(client, TFCond_SpeedBuffAlly); }
stock bool:isKritzed(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Kritzkrieged); }
stock bool:isBonked(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Bonked); }
stock bool:isJarated(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Jarated); }
stock bool:isDazed(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Dazed); }
stock bool:isCharging(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Charging); }
stock bool:isDemoBuff(client)
{ return TF2_IsPlayerInCondition(client, TFCond_DemoBuff); }
stock bool:isBeingHealed(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Healing); }
stock bool:isCloaked(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Cloaked); }
stock bool:isUbered(client)
{ return TF2_IsPlayerInCondition(client, TFCond_Ubercharged); }
stock bool:isOnFire(client)
{ return TF2_IsPlayerInCondition(client, TFCond_OnFire); }

stock addFlagNoTarget(client)
{ SetEntProp(client, Prop_Data, "m_fFlags", (GetEntityFlags(client) | (1 << 16))); }
stock remFlagNoTarget(client)
{ SetEntProp(client, Prop_Data, "m_fFlags", (GetEntityFlags(client) & ~(1 << 16))); }
      
stock bool:isGrounded(client)
{ return (GetEntityFlags(client) & (FL_ONGROUND | FL_INWATER)) != 0; }
stock bool:isCrouching(client)
{ return (GetEntityFlags(client) & FL_DUCKING) != 0; }

stock addInvincibility(client)
{ SetEntProp(client, Prop_Data, "m_takedamage", 0, 1); }
stock remInvincibility(client)
{ SetEntProp(client, Prop_Data, "m_takedamage", 2, 1); }

////////////////////////////////////////////////////////////
//
// Attribute / Flags Utils (Complex)
//
////////////////////////////////////////////////////////////
stock bool:isInWater(client)
{ return GetEntProp(client, Prop_Send, "m_nWaterLevel") > 0; }

stock bool:isNotMoving(client)
{
  decl Float:vel[3];
  GetEntPropVector(client, Prop_Data, "m_vecVelocity", vel);
  return (GetVectorLength(vel, true) == 0);  
}

stock getEntityPos(entity, Float:pos[3])
{ GetEntPropVector(entity, Prop_Send, "m_vecOrigin", pos); }

////////////////////////////////////////////////////////////
//
// Health Utils
//
////////////////////////////////////////////////////////////
stock Float:getHealthPct(client)
{
  return GetClientHealth(client) / float(clientMaxHealth(client));  
}

stock setHealthPct(client, Float:healthPct)
{
  new newHealth = RoundToCeil(clientMaxHealth(client)*healthPct);
  SetEntityHealth(client, newHealth);
}

stock clientMaxHealth(client)
{
  new mh = GetEntProp(client, Prop_Data, "m_iMaxHealth");
  switch (TF2_GetPlayerClass(client))
  { 
    //
    // Handle demoman bonuses
    // + Headcount from Eyelander / Headtaker / nessie nine iron
    //
    case TFClass_DemoMan:
    {
      if(isEquipped(client, ZFWEAP_EYELANDER) || isEquipped(client, ZFWEAP_FESTIVEEYELANDER) || isEquipped(client, ZFWEAP_HHHHEADTAKER) || isEquipped(client, ZFWEAP_NESSIESNINEIRON))
      {
        new heads = GetEntProp(client, Prop_Send, "m_iDecapitations");
        mh += min(heads, 4) * 15;
      }
    }
  }
  return mh; 
}

////////////////////////////////////////////////////////////
//
// Speed Utils
//
////////////////////////////////////////////////////////////
stock setClientSpeed(client, Float:speed)
{ SetEntDataFloat(client, oMaxspeed, speed, true); }

stock Float:clientBaseSpeed(client)
{
  switch (TF2_GetPlayerClass(client))
  { 
    case TFClass_Soldier:  return 240.0;  // Default 240.0
    case TFClass_DemoMan:  return 280.0;  // Default 280.0
    case TFClass_Medic:    return 320.0;  // Default 320.0
    case TFClass_Pyro:     return 240.0;  // Default 300.0 <Slowed>
    case TFClass_Engineer: return 300.0;  // Default 300.0
    case TFClass_Sniper:   return 300.0;  // Default 300.0
    case TFClass_Scout:    return 350.0;  // Default 400.0 <Slowed>
    case TFClass_Spy:      return 280.0;  // Default 300.0 <Slowed>
    case TFClass_Heavy:    return 230.0;  // Default 230.0
  }
  return 0.0;
}

stock Float:clientBonusSpeed(client)
{
  //1. handle jarate speed debuff
  //   Being jarated causes -40 speed
  //   penalty isJarated(client)
  if(isJarated(client))
  {
    return -40.0;
  }
  switch (TF2_GetPlayerClass(client))
  { 
    //
    // Handle soldier bonuses
    // + Wielding Equalizer
    //
    case TFClass_Soldier:
    {      
      if(isWielding(client, ZFWEAP_ESCAPEPLAN))
      {
        new curH = GetClientHealth(client);
        if(curH > 160) return 0.0;
        if(curH > 120) return 24.0;
        if(curH > 80)  return 48.0;
        if(curH > 40)  return 96.0;
        if(curH > 0)   return 144.0;
      }
    }

    //
    // Handle demoman bonuses
    // + Headcount from Eyelander / HHHHeadtaker
    // + Wielding Skullcutter
    //
    case TFClass_DemoMan:
    {
      if(isEquipped(client, ZFWEAP_EYELANDER) || isEquipped(client, ZFWEAP_FESTIVEEYELANDER) || isEquipped(client, ZFWEAP_HHHHEADTAKER) || isEquipped(client, ZFWEAP_NESSIESNINEIRON))
      {
        new heads = GetEntProp(client, Prop_Send, "m_iDecapitations");
        return min(heads, 4) * 22.5;
      }
      else if(isEquipped(client, ZFWEAP_SKULLCUTTER))
      {
        return -42.0;
      }
    }

    //
    // Handle heavy bonuses
    // + Wielding GRU
    // + Equipping Warrior's Spirit (ZF-only penalty due to attack bonus)
    // + Equipping Fists of Steel (ZF-only penalty due to ranged defense bonus)
    // + Equipping Holiday Punch (ZF-only penalty due to backstab like mechanics)
	//
    case TFClass_Heavy:
    {
      new Float:speed = 0.0;
      if(isWielding(client, ZFWEAP_GRU) || isWielding(client, ZFWEAP_FESTIVEGRU))
      {
        speed += 40.0;
      }
      else if(isEquipped(client, ZFWEAP_WARRIORSSPIRIT))
      {
        speed -= 40.0;
      }
      else if(isEquipped(client, ZFWEAP_FISTSOFSTEEL))
      {
        speed -= 30.0;
      }
	  else if(isEquipped(client, ZFWEAP_HOLIDAYPUNCH))
      {
        speed -= 40.0;
      }
	  else if(isEquipped(client, ZFWEAP_EVICTIONNOTICE))
      {
        speed -= 30.0;
      }
      return speed;
    }
	//
    // Handle spy bonuses
    // + Equipping Spycicle (ZF-only penalty due to pyro immunity)
	//
	/*case TFClass_Spy:
    {
      new Float:speed = 0.0;
      if(isEquipped(client, ZFWEAP_SPYCICLE))
      {
        speed -= 20.0;
      }
      return speed;
    }*/
  } 
  return 0.0;
}

////////////////////////////////////////////////////////////
//
// Entity Name Utils
//
////////////////////////////////////////////////////////////
stock bool:entClassnameContains(ent, const String:strRefClassname[])
{
  if(IsValidEdict(ent) && IsValidEntity(ent))
  {
    decl String:strName[32];
    GetEdictClassname(ent, strName, sizeof(strName));
    return (StrContains(strName, strRefClassname, false) != -1);
  }
  return false;
}

////////////////////////////////////////////////////////////
//
// Glow Utils
//
////////////////////////////////////////////////////////////
stock setGlow(client, bool:glowEnabled)
{
  SetEntProp(client, Prop_Send, "m_bGlowEnabled", (glowEnabled ? 1 : 0));
}

////////////////////////////////////////////////////////////
//
// Razerback Utils
//
////////////////////////////////////////////////////////////
stock bool:HasRazorback(client) 
{
    new entity = -1;
    while ((entity = FindEntityByClassname(entity, "tf_wearable")) != -1)
    {
        if (IsClassname(entity, "tf_wearable") && GetEntPropEnt(entity, Prop_Send, "m_hOwnerEntity") == client && GetEntProp(entity, Prop_Send, "m_iItemDefinitionIndex") == 57) return true;
    }
    return false;
}
stock bool:IsClassname(iEntity, String:strClassname[]) 
{
    if (iEntity <= 0) return false;
    if (!IsValidEdict(iEntity)) return false;
    
    decl String:strClassname2[32];
    GetEdictClassname(iEntity, strClassname2, sizeof(strClassname2));
    if (StrEqual(strClassname, strClassname2, false)) return true;
    return false;
}

////////////////////////////////////////////////////////////
//
// Sentry Utils
//
////////////////////////////////////////////////////////////
stock bool:entIsSentry(ent)
{ return entClassnameContains(ent, "obj_sentrygun"); }

////////////////////////////////////////////////////////////
//
// Cloak Utils
// + Range 0.0 to 100.0
//
////////////////////////////////////////////////////////////
stock Float:getCloak(client)
{ 
  if(isSpy(client))
  {
    return GetEntDataFloat(client, oCloakMeter);
  }
  return 0.0;
}

stock setCloak(client, Float:cloakPct)
{ 
  if(isSpy(client)) 
  {
    SetEntDataFloat(client, oCloakMeter, cloakPct, true);
  }
}

////////////////////////////////////////////////////////////
//
// Uber Utils
// + Range 0.0 to 1.0
//
////////////////////////////////////////////////////////////
stock addUber(client, Float:uberPct)
{
  new weapon = GetPlayerWeaponSlot(client, 1);
  if(weapon > 0 && isMedic(client))
  {
    new Float:curPct = GetEntPropFloat(weapon, Prop_Send, "m_flChargeLevel");
    SetEntPropFloat(weapon, Prop_Send, "m_flChargeLevel", fMin((curPct + uberPct), 1.0));
  }
}

stock subUber(client, Float:uberPct)
{ 
  new weapon = GetPlayerWeaponSlot(client, 1);
  if(weapon > 0 && isMedic(client))
  {
    new Float:curPct = GetEntPropFloat(weapon, Prop_Send, "m_flChargeLevel");
    SetEntPropFloat(weapon, Prop_Send, "m_flChargeLevel", fMax((curPct - uberPct), 0.0));
  }
}

////////////////////////////////////////////////////////////
//
// Metal Add/Sub Utils
//
////////////////////////////////////////////////////////////
stock addMetalPct(client, Float:metalPct, Float:metalLimitPct = 1.0)
{
  if(isEngineer(client))
  {
    new curMetal = getMetal(client);
    new maxMetal = 200;
    new metal = RoundToCeil(maxMetal * metalPct);
    setMetal(client, min((curMetal + metal), RoundToCeil(maxMetal * metalLimitPct)));
  }
}

stock subMetalPct(client, Float:metalPct)
{
  if(isEngineer(client))
  {
    new curMetal = getMetal(client);
    new maxMetal = 200;
    new metal = RoundToCeil(maxMetal * metalPct);
    subMetal(client, max((curMetal - metal), 0);
  }
}

stock addMetal(client, metal)
{
  if(isEngineer(client))
  {
    new curMetal = getMetal(client);
    setMetal(client, min((curMetal + metal), 200)); 
  }
}

stock subMetal(client, metal)
{
  if(isEngineer(client))
  {
    new curMetal = getMetal(client);
    setMetal(client, max((curMetal - metal), 0)); 
  }
}

////////////////////////////////////////////////////////////
//
// Metal Get/Set Utils
//
////////////////////////////////////////////////////////////
stock getMetal(client)
{ return GetEntData(client, oResAmmo[2]); }

stock setMetal(client, metal)
{ SetEntData(client, oResAmmo[2], min(metal, 255), true); }

////////////////////////////////////////////////////////////
//
// Ammo Add/Sub Utils
//
////////////////////////////////////////////////////////////
stock addClipAmmoPct(client, slot, Float:ammoPct, Float:ammoLimitPct = 1.0)
{
  new curAmmo = getClipAmmo(client, slot);
  new maxAmmo = maxClipAmmo(client, slot);
  new ammo = RoundToCeil(maxAmmo * ammoPct);
  setClipAmmo(client, slot, min((curAmmo + ammo), RoundToCeil(maxAmmo * ammoLimitPct)));
}

stock subClipAmmoPct(client, slot, Float:ammoPct)
{
  new curAmmo = getClipAmmo(client, slot);
  new maxAmmo = maxClipAmmo(client, slot);
  new ammo = RoundToCeil(maxAmmo * ammoPct);
  setClipAmmo(client, slot, max(curAmmo - ammo, 0));
}

stock addResAmmoPct(client, slot, Float:ammoPct, Float:ammoLimitPct = 1.0)
{
  new curAmmo = getResAmmo(client, slot);
  new maxAmmo = maxResAmmo(client, slot);
  new ammo = RoundToCeil(maxAmmo * ammoPct);
  setResAmmo(client, slot, min((curAmmo + ammo), RoundToCeil(maxAmmo * ammoLimitPct)));
}

stock subResAmmoPct(client, slot, Float:ammoPct)
{
  new curAmmo = getResAmmo(client, slot);
  new maxAmmo = maxResAmmo(client, slot);
  new ammo = RoundToCeil(maxAmmo * ammoPct);
  setResAmmo(client, slot, max(curAmmo - ammo, 0));
}

stock addClipAmmo(client, slot, ammo)
{
  new curAmmo = getClipAmmo(client, slot);
  new maxAmmo = maxClipAmmo(client, slot);
  new newAmmo = min(curAmmo + ammo, maxAmmo);
  setClipAmmo(client, slot, newAmmo); 
}

stock subClipAmmo(client, slot, ammo)
{
  new curAmmo = getClipAmmo(client, slot);
  setClipAmmo(client, slot, max((curAmmo - ammo), 0));
}

stock addResAmmo(client, slot, ammo)
{
  new curAmmo = getResAmmo(client, slot);
  new maxAmmo = maxResAmmo(client, slot);
  new newAmmo = min(curAmmo + ammo, maxAmmo);
  setResAmmo(client, slot, newAmmo);
}

stock subResAmmo(client, slot, ammo)
{
  new curAmmo = getResAmmo(client, slot);
  setResAmmo(client, slot, max((curAmmo - ammo), 0));
}

////////////////////////////////////////////////////////////
//
// Ammo Set/Get Utils
//
//////////////////////////////////////////////////////////// 
stock Float:getClipAmmoPct(client, slot)
{
  new curAmmo = getClipAmmo(client, slot);
  new maxAmmo = maxClipAmmo(client, slot);
  return (maxAmmo == 0) ? 0.0 : float(curAmmo)/float(maxAmmo);
}

// TODO setClipAmmoPct

stock Float:getResAmmoPct(client, slot)
{
  new curAmmo = getResAmmo(client, slot);
  new maxAmmo = maxResAmmo(client, slot);
  return (maxAmmo == 0) ? 0.0 : float(curAmmo)/float(maxAmmo);  
}

// TODO setResAmmoPct

stock getClipAmmo(client, slot)
{
  new weapon = GetPlayerWeaponSlot(client, slot);
  return (weapon > 0) ? GetEntData(weapon, oClipAmmo) : 0;
}

stock setClipAmmo(client, slot, ammo)
{
  new weapon = GetPlayerWeaponSlot(client, slot);
  if(weapon > 0) SetEntData(weapon, oClipAmmo, min(ammo, 255), true);
}

stock getResAmmo(client, slot)
{
  return GetEntData(client, oResAmmo[slot]);
}

stock setResAmmo(client, slot, ammo)
{
  SetEntData(client, oResAmmo[slot], min(ammo, 255), true);
}

////////////////////////////////////////////////////////////
//
// Ammo Max Utils
//
//////////////////////////////////////////////////////////// 
stock maxClipAmmo(client, slot)
{
  new weaponId = slotWeaponId(client, slot);
  if(weaponId >= 0)
  {
    if(weaponId >= MAX_ZF_WEAPONS)
      LogError("[ZF] - maxClipAmmo() - Invalid weaponId: %d", weaponId);
    else
      return ((ZF_WEAPON_DATA[weaponId] & M_MAXCLIPAMMO) >> S_MAXCLIPAMMO);
  }
  return 0;
}

stock maxResAmmo(client, slot)
{
  new weaponId = slotWeaponId(client, slot);
  if(weaponId >= 0)
  {
    if(weaponId >= MAX_ZF_WEAPONS)
      LogError("[ZF] - maxResAmmo() - Invalid weaponId: %d", weaponId);
    else
      return ((ZF_WEAPON_DATA[weaponId] & M_MAXRESAMMO) >> S_MAXRESAMMO);
  }
  return 0;
}

////////////////////////////////////////////////////////////
//
// Spawn Utils
//
////////////////////////////////////////////////////////////
stock spawnClient(client, nextClientTeam)
{
//   // DEBUG
//   PrintToChat(client, "[ZF] spawnClient %d %d", client, _:TF2_GetPlayerClass(client));
      
  // 1. Prevent players from spawning if they're on an invalid team.
  //    Prevent players from spawning as an invalid class.
  if(IsClientInGame(client) && (isSur(client) || isZom(client)))
  {    
    new TFClassType:nextClientClass = TF2_GetPlayerClass(client);
    if((nextClientTeam == zomTeam()) && !validZombie(nextClientClass))
    {
      nextClientClass = randomZombie();
    }
    if((nextClientTeam == surTeam()) && !validSurvivor(nextClientClass))
    {
      nextClientClass = randomSurvivor();    
    }
 
    // Use of m_lifeState here prevents:
    // 1. "[Player] Suicided" messages.
    // 2. Adding a death to player stats.
    SetEntProp(client, Prop_Send, "m_lifeState", 2); 
    TF2_SetPlayerClass(client, nextClientClass, false, true);   
    ChangeClientTeam(client, nextClientTeam);
    SetEntProp(client, Prop_Send, "m_lifeState", 0);      
    TF2_RespawnPlayer(client);      
  }
}

setTeamRespawnTime(team, Float:time)
{
  new index = FindEntityByClassname(-1, "tf_gamerules");
  if(index != -1)
  {
    SetVariantFloat(time/2.0);
    if(team == _:TFTeam_Blue)
      AcceptEntityInput(index, "SetBlueTeamRespawnWaveTime", -1, -1, 0);
    if(team == _:TFTeam_Red)
      AcceptEntityInput(index, "SetRedTeamRespawnWaveTime", -1, -1, 0);
  }       
}

////////////////////////////////////////////////////////////
//
// Damage Utils
//
////////////////////////////////////////////////////////////
stock applyDamage(
  damage, 
  victim, 
  damagetype = DMG_GENERIC)
{ 
  if((damage <= 0) || !validLivingClient(victim))
    return;

  // Apply damage.
  new ent = CreateEntityByName("point_hurt");
  if(IsValidEntity(ent))
  {
    decl String:strDamage[16];
    decl String:strDamageType[16];
    decl String:strDamageTarget[16];
    decl String:strAddOutput[64];
    
    Format(strDamage, sizeof(strDamage), "%d", damage);
    Format(strDamageType, sizeof(strDamageType), "%d", damagetype);
    Format(strDamageTarget, sizeof(strDamageTarget), "%s%d", ZF_DAMAGEPOINT_NAME, victim);

    // Config, create point_hurt
    DispatchKeyValue(victim, "targetname", strDamageTarget);
    DispatchKeyValue(ent, "Damage", strDamage);
    DispatchKeyValue(ent, "DamageType", strDamageType);
    DispatchKeyValue(ent, "DamageTarget", strDamageTarget);
    DispatchSpawn(ent);

    // Hurt in 0.01s.
    Format(strAddOutput, sizeof(strAddOutput), "OnUser1 !self:hurt::%f:1", 0.01); // TODO: set attacker?
    SetVariantString(strAddOutput);
    AcceptEntityInput(ent, "AddOutput");
    AcceptEntityInput(ent, "FireUser1");
    
    // Kill in 0.02s.
    Format(strAddOutput, sizeof(strAddOutput), "OnUser2 !self:kill::%f:1", 0.02);
    SetVariantString(strAddOutput);
    AcceptEntityInput(ent, "AddOutput");
    AcceptEntityInput(ent, "FireUser2");
  }
  else
  {
    LogError("[ZF] applyDamage (%d, %d) failed.", damage, victim); 
  }  
  
  return;
}

stock applyDamageRadialAtClient(
  client, 
  damage, 
  radius, 
  bool:doFx = false)
{
  decl Float:pos[3];
  GetClientEyePosition(client, pos);
  applyDamageRadial(client, damage, pos, radius, doFx);  
}

stock applyDamageRadial(
  attacker, 
  damage, 
  const Float:pos[3],
  radius, 
  bool:doFx = false)
{
  if((damage <= 0) || (radius <= 0) || !validClient(attacker))
    return;

  // Apply explosion damage.
  new ent = CreateEntityByName("env_explosion");
  if(IsValidEntity(ent))
  {
    decl String:strTargetName[16];
    decl String:strAddOutput[64];
    Format(strTargetName, sizeof(strTargetName), "%s%d", ZF_DAMAGERADIUS_NAME, ent);

    // Config, create env_explosion
    DispatchKeyValue(ent, "targetname", strTargetName); 
    SetEntProp(ent, Prop_Data, "m_iMagnitude", damage);
    SetEntProp(ent, Prop_Data, "m_iRadiusOverride", radius);
    SetEntProp(ent, Prop_Data, "m_spawnflags", (doFx ? 0x0 : 0x3FC));
    SetEntPropEnt(ent, Prop_Data, "m_hInflictor", attacker);
    SetEntPropEnt(ent, Prop_Data, "m_hOwnerEntity", attacker); 
    SetEntPropEnt(ent, Prop_Data, "m_hEntityIgnore", attacker); // Prevent self-damage
    SetEntPropFloat(ent, Prop_Data, "m_flDamageForce", 100.0);  // TODO Why is this here?
    DispatchSpawn(ent);

    // Teleport env_explosion
    TeleportEntity(ent, pos, NULL_VECTOR, NULL_VECTOR);
        
    // Explode in 0.01s.
    Format(strAddOutput, sizeof(strAddOutput), "OnUser1 !self:explode::%f:1", 0.01);
    SetVariantString(strAddOutput);
    AcceptEntityInput(ent, "AddOutput");
    AcceptEntityInput(ent, "FireUser1");
    
    // Kill in 0.02s.
    Format(strAddOutput, sizeof(strAddOutput), "OnUser2 !self:kill::%f:1", 0.02);
    SetVariantString(strAddOutput);
    AcceptEntityInput(ent, "AddOutput");
    AcceptEntityInput(ent, "FireUser2");
  }
  else
  {
    LogError("[ZF] applyDamageRadial (%d, %d, [%2.2f,%2.2f,%2.2f], %d) failed.", attacker, damage, pos[0], pos[1], pos[2], radius); 
  }
  
  return;  
}